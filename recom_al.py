import pandas as pd
import numpy as np
from skimage.io import imread

def get_rating(row,C,m):
    """
    It calculates the imdb user based ratings with a formula.
    
    Args:
        row: the row of the dataframe which contains the movie votes and vote average.
        C: is the mean rating of the movies to be in the charts.
        m: is the minimum no. of ratings to remain in the charts.
        
    Returns:
        float(rating).
    """
    
    return float("%1.1f"%((row.vote_average*row.vote_count+m*C)/(row.vote_count+m)))


def cont_based(inp_frame,feature_set,ratings):
    """
    The function calculates demographic recommendations by contructing similarity matrix.
    
    Args:
        inp_frame: is the user input frame generated by search engine in the program itself.
        feature_set: It is the matrix containing feature information about movies corresponding to the index number. 
        ratings: is the dataframe containing ratings of movies.
        
    Returns:
        DataFrame
    """
    
    feature_set_inp=feature_set[inp_frame.index]
    inp_rating=inp_frame['ratings'].values

    genre_rate=inp_rating.reshape(1,-1).dot(feature_set_inp)
    similarity=feature_set.dot(genre_rate.reshape(-1,1))
    
    similarity_mov=pd.DataFrame(similarity,columns=['similarity'])
    similarity_mov=pd.concat([similarity_mov,ratings],axis=1)
    similarity_mov=similarity_mov[~similarity_mov.imdb_id.isin(inp_frame.imdb_id)]
    print('model_1 implemented successfully.')
    return similarity_mov.sort_values(by='similarity',ascending=False)


def user_based():
    """
    under development
    """
    print("preparing for model_2...")
    user_votes=ratings['userId'].value_counts()
    lb=user_votes.quantile(0.5)
    ub=user_votes.quantile(0.8)
    user_counts=ratings['userId'].value_counts()
    top_users=user_counts[(user_counts.values>lb)&(user_counts.values<ub)]
    ref_ratings=ratings[ratings.userId.isin(top_users.index)]

    other_users=ref_ratings[ref_ratings['movieId'].isin(inp_frame['movieId'])]

    criteria=(other_users['userId'].value_counts()>1)[0:1000]
    other_users=other_users[other_users.userId.isin(criteria[criteria.values].index)]
    other_users=other_users.groupby('userId')
    
    
    warnings.filterwarnings('ignore')
    print('implementing model_2...')
    sim_index=other_users.apply(similarity)
    print('done!')
    
    print('fetching results...')
    sim_matrix=pd.DataFrame({'userId':sim_index.index,'sim_index':sim_index.values})
    final_frame=pd.merge(left=sim_matrix,right=ref_ratings,how='inner')

    final_frame['weighted_av']=final_frame['rating']*final_frame['sim_index']
    output_user=final_frame.groupby('movieId').sum()[['sim_index','weighted_av']]
    output_user['rating']=output_user['weighted_av']/output_user['sim_index'].replace(0.0,np.nan)

    output_user=output_user.sort_values(by='rating',ascending=False).reset_index()
    output_user=output_user.drop(['sim_index','weighted_av'],axis=1)
    print('done!')
